---
title: cpp-inheritance
tags:
---

### Inheritance in C++ 继承

<!--more-->

### 继承声明

- 类在声名的时候并不需要去声明继承了哪个类，在具体类的实现的时候才需要进行声明

  - 主要是适用于一些提前声明的情况，比如说前向声明

  - ```cpp
    //错误声明
    class Undergraduated_Student : public Student;//声明的时候是不用声明继承的
    //正确声明
    class Undergraduated_Student;
    
    ```

- 派生类中**对父类的重名方法是重写**，期望被重写的部分的前面**添加`Virtual`来保证子类重写**。

- 父类中的所有部分都会被子类的名空间覆盖，但是通过命名空间也可以访问，如果父类中的`public`没有被子类复写，则可以调用

- **构造函数**、**析构函数**和**运算符重载函数**是**不会被继承**的。



### [继承中的访问权限](./10-oo-cpp#七、继承方式)

1. 如果没有继承的话，`protected`和`private`的访问权限是相同的
2. 在 `public` 继承的情况下
   1. 派生类可以访问基类中 `protected` 的属性的成员。
   2. 派生类不可以访问**基类中的对象**的 `provite` 的属性。

### 继承的初始化顺序

派生类对象的初始化：由**基类和派生类**共同完成

#### 构造函数的执行次序

1. 基类的构造函数
2. **派生类对象成员类的构造函数(注意！)**
3. 派生类的构造函数

>[!TIP]
>
>- 初始化列表的书写顺序不影响成员变量和基类的初始化顺序。
>
>- ```cpp
>  Student(string id, string name) : id(id), Person(name) {
>      printName();
>   } // 依旧会先执行  Person(name) 基类构造函数

#### 析构函数的执行次序(与构造函数执行顺序相反)

1. 派生类的析构函数
2. 派生类对象成员类的析构函数
3. 基类的析构函数



#### 基类构造函数的调用

+ **缺省执行基类默认构造函数**
+ 如果要执行基类的**非默认构造函数**，则必须在**派生类构造函数的成员初始化表中指出**

### 派生类中使用基类的函数和变量



### 多继承

#### 定义

```cpp
class <派生类名>：[<继承方式>] <基类名1>，
                 [<继承方式>] <基类名2>，…
{〈成员表〉}
```

名冲突用命名空间来解决，但后面更应用虚基类虚继承解决。

#### 基类声明顺序(初始化顺序)

<img src="https://ydjsir-cn.oss-cn-shenzhen.aliyuncs.com/notes/C%2B%2B%20exam.assets/11.png" alt="11" style="zoom: 67%;" />

#### 基类的声明次序

1. 对基类构造函数的调用次序(顶部基类，**同层基类按照声明顺序**) 上图中就是 ABCD的顺序
2. 对基类数据成员的存储安排

#### 析构顺序

析构函数的执行顺序与上面的类构造顺序正好相反

### 虚基类

#### 为什么会有虚基类

解决菱形继承问题：如上图所示

- 类D继承自类B和类C
- 类B和类C都继承自类A
- 不使用虚继承时，类D会包含两份类A的成员
- 导致数据冗余和访问二义性

#### 什么是虚基类

虚基类是通过关键字 `virtual` 继承而来的基类，用于解决 C++多重继承时的数据冗余和二义性问题。

- 确保在继承体系中共享基类只有一个实例
- 避免多重**继承时的成员重复**
- 解决菱形继承问题

```c++
class A;
class B: virtual public A;
class C: public virtual A;
//public virtual 和 virtual public是一致的
class D: B, C;
```



### 类型相容与赋值相容

#### 类型相容

类型相容（Type Compatibility）是指在特定上下文中，一个类型的值可以被视为另一个类型的值，而不会引起编译错误或运行时错误。

类型相容的规则：

- **基本类型相容**：某些基本类型之间可以相互转换，例如 `int` 和 `double`。

- **指针类型相容**：指向**派生类的指针可以赋值给指向基类的指针**。

- **引用类型相容**：**派生类的引用可以赋值给基类的引用**。

  - 不能将基类赋值给派生类

- **数组类型相容**：数组类型的相容性取决于其元素类型的相容性。

- **函数类型相容**：函数指针类型的相容性取决于其**参数和返回类型的相容性**。

  ```cpp
  #include <iostream>
  
  class Base {
  public:
      virtual void print() { std::cout << "Base" << std::endl; }
  };
  
  class Derived : public Base {
  public:
      void print() override { std::cout << "Derived" << std::endl; }
  };
  
  void demonstrate() {
      // 基本类型相容
      int i = 42;
      double d = i;  // int 可以赋值给 double
  
      // 指针类型相容
      Derived derived;
      Base* basePtr = &derived;  // 派生类指针可以赋值给基类指针
      basePtr->print();  // 输出：Derived
  
      // 引用类型相容
      Base& baseRef = derived;  // 派生类引用可以赋值给基类引用
      baseRef.print();  // 输出：Derived
  
      // 错误示例：基类指针不能赋值给派生类指针
      Base base;
      // Derived* derivedPtr = &base;  // 错误：基类指针不能赋值给派生类指针
  
      // 错误示例：基类引用不能赋值给派生类引用
      // Derived& derivedRef = base;  // 错误：基类引用不能赋值给派生类引用
  }
  
  int main() {
      demonstrate();
      return 0;
  }
  ```

  

#### 赋值相容（不会丢失信息）

- 对于类型相同的变量才有(`a = b`)
- 如果类型相同可以直接赋值
- 子类型可以赋值给父类型

+ `A a; B b; class B: public A` 将 B 赋值 给 A 后
  + 对象的身份发生变化(a和b都代表栈上对应大小的内存),**B类型对象变为了A类型的对象**
  + **属于派生类的属性已不存在**
  + 将派生类对象赋值给基类对象->**对象切片**
+ `A a = b`:调用拷贝构造函数
+ `const A &a`:函数必然包含的拷贝构造函数中的参数
+ `B* pb;  A* pa = pb; class B: public A`
  + 因为是赋值相容的，**所以可以指针赋值**
  + 这种情况类似 Java
+ `B  b; A & a=b; class B: public A`：**对象身份没有发生变化(还是B)**

##### 尽量不要拷贝传参

传参的时候尽量不要拷贝传参(存在对象切片问题)，而是使用引用传参。

```cpp
class A{
    int x,y;
    public:
        void f();
};
class B: public A{
    int z;
    public:
	    void f();
	    void g();
};
//把派生类对象赋值给基类对象
A a;
B b;
a = b;     //OK, 
b = a;     //Error
a.f();     //A::f()

//基类的引用或指针可以引用或指向派生类对象
A &r_a = b;     //OK
A *p_a = &b;    //OK

B &r_b = a;     //Error
B *p_b = &a；   //Error
//这里通过赋值相容，已经对对象完成了切片
func1(A& a){a.f();}
func1(b);//A::f
```

### 虚函数表

#### 1. 虚函数表的概念

虚函数表（vtable）**是一个指针数组**，每个指针指向一个虚函数的实现。每个包含虚函数的类都有一个虚函数表，类的每个对象都有一个指向该虚函数表的指针（vptr）。

#### 2. 虚函数表的作用

- 实现动态绑定（运行时多态）
- 通过虚函数表指针（vptr）在运行时确定调用哪个函数

#### 3. 虚函数表的结构

- **每个包含虚函数的类都有一个虚函数表**
- 虚函数表包含指向虚函数实现的指针
- 对象通过 vptr 指向虚函数表

### 继承中函数调用的选择

函数调用规则总结

#### 1. 构造函数期间的虚函数调用

- 在基类构造函数期间调用虚函数时，调用的是基类的版本，而不是派生类的版本。
- 原因是**此时派生类对象尚未构造完成，虚函数表指针（vptr）仍指向基类的虚函数表。**

#### 2. 静态绑定与动态绑定

- **静态绑定**：编译时确定函数调用，适用于非虚函数。
  - 取决于对象引用或者指针的类型
- **动态绑定**：运行时确定函数调用，适用于虚函数。 

#### 3. 继承中的函数调用次序

- **非虚函数**：调用基类或派生类的实现，**取决于指针或引用的类型**。
- **虚函数**：通过**虚函数表在运行时**确定调用派生类的实现。

```cpp
class A {
public:
    A() { f(); }  // 构造函数中调用虚函数
    virtual void f();
    void g();
    void h() {
        f();
        g();
    }
};

class B : public A {
public:
    void f() override;
    void g();
};

B b;  // 对象构造顺序：A::A() -> A::f() -> B::B()

A* p = &b;
p->f();  // 动态绑定，调用 B::f()
p->g();  // 静态绑定，调用 A::g()
p->h();  // 静态绑定，调用 A::h() -> 动态绑定，调用 B::f() -> 静态绑定，调用 A::g()
```

`h()`函数是**非虚接口**

- 有不同的实现:**调用了虚函数和非虚函数**
- **可以替换部分的实现**
- 可以使得非虚函数具有虚函数的特性(让全局函数具有多态:将全局函数做成非虚接口)

### 虚函数限制

1. 类的成员函数才可以是虚函数:**全局函数不可以是虚函数**
2. **静态成员函数不能是虚函数**:静态的成员函数属于类，并不属于一个对象，所以不能虚函数
3. **内联成员函数不能是虚函数**:内联成员函数在编译的时候就已经确定了
4. **构造函数不能是虚函数**:
   1. 因为创建类的时候是自动调用的，父类的指针无法直接调用，虚函数没有意义；
   2. 虚函数表是在构造函数中完成的；
5. **析构函数可以(往往)是虚函数**：如果不是虚函数，不好调用到派生类中的析构函数（delete一个父类指针，如果非虚，不能调用到派生类的析构函数）
   1. 如果**有继承的话，最好使用虚析构函数**，在调用析构的函数，会**先**调用基类的析构函数，所以:
   2. 在析构函数中，**只需要析构派生类自己的资源就可以了**

### `final` & `override` 关键字

- **`override`**：确保**派生类中的函数确实重写了基类中的虚函数**。
- **`final`**：防止派生类重写虚函数或进一步派生。

#### `override` 关键字

- 用于派生类的函数声明中，表示该函数重写了**基类的虚函数**。

- 编译器会检查基类中**是否存在具有相同签名的虚函数，如果没有编译器则报错**。

  ```cpp
  class Base {
  public:
      virtual void foo() { std::cout << "Base::foo" << std::endl; }
      virtual void bar(int) { std::cout << "Base::bar" << std::endl; }
  };
  
  class Derived : public Base {
  public:
    // override 保证基类中一定有一个foo的虚函数
      void foo() override { std::cout << "Derived::foo" << std::endl; }  // 正确重写
      // void bar(double) override { std::cout << "Derived::bar" << std::endl; }  // 错误：签名不匹配
  };
  ```

#### `final` 关键字

- 用于**虚函数声明**中，表示该函数不能被进一步重写。

- 用于**类声明**中，表示该类不能被进一步继承。

  ```cpp
  class Base {
  public:
      virtual void foo() final { std::cout << "Base::foo" << std::endl; }  // 不能被重写
  };
  
  class Derived : public Base {
  public:
      // void foo() override { std::cout << "Derived::foo" << std::endl; }  // 错误：foo 被 final 修饰
  };
  
  ```

  

### 继承中的注意点

- 不要定义与继承而来的非虚成员函数同名的成员函数

  - 会导致一个对象使用不同类型的指针进行调用的时候可能会调用不同的函数

    ```cpp
    class B {
        public:
    	    void mf();
    };
    class D: public B { 
        public:
            void mf();
    };
    D x;
    B* pB = &x;
    pB->mf();//B:mf 都是静态绑定 调用哪个函数取决于当前指针的类型
    D* pD = &x;
    pD->mf();//D:mf
    ```

- 绝对不要重新定义继承而来的缺省参数值！

  - 默认参数值在编译时绑定（静态绑定的），而虚函数调用在运行时绑定，这会导致不一致的行为。

  - 对象的虚函数表（vtable）中只记录虚函数的入口地址，不记录默认参数值。

    ```cpp
    #include <iostream>
    using namespace std;
    
    class A {
    public:
        virtual void f(int x = 0) = 0;  // 纯虚函数，默认参数值为0
    };
    
    class B : public A {
    public:
        virtual void f(int x = 1) override {  // 重写虚函数，默认参数值为1
            cout << x;
        }
    };
    
    class C : public A {
    public:
        virtual void f(int x) override {  // 重写虚函数，没有默认参数值
            cout << x;
        }
    };
    
    int main() {
        A* p_a;  // 这里编译的时候已经绑定了缺省值 0
        B b;
        p_a = &b;
        p_a->f();  // 虽然这里通过虚函数重写调用了 B::f 但是缺省值为0 
      						 // 所以实际上这里的调用是 B::f(0) 输出0 
    
        A* p_a1;
        C c;
        p_a1 = &c;
        p_a1->f();  // 输出0 同上 这里也绑定了缺省值 0
    
        return 0;
    }
    ```

### 纯虚函数 & 抽象类

#### 纯虚函数（类似 Java 中接口的方法）

1. 声明时在**虚函数原型**后面加上 **= 0**
   - `virtual int f() = 0;`
2. **往往**只给出函数声明，不给出实现：可以给出实现，通过函数外进行定义(但是不好访问，因为查到是0)
3. 子类**必须继承接口，并给出实现**

```cpp
int f() = 0;
int f(){
    Base::f;//显式调用基类中纯虚函数的定义
}
```

#### 抽象类（类似 Java 中的接口）

1. **至少包含一个纯虚函数**
2. **不能用于创建对象**:抽象类类似一个接口，提供一个框架
3. 为派生类提供框架，派生类提供抽象基类的所有成员函数的实现

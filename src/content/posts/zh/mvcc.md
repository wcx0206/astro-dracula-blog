---
title: mvcc
tags:
 - database
date: 2025-02-25 09:46:35
---

数据库多版本并发控制机制 （MVCC - Multi-Version Concurrency Control）

<!--more-->

文章参考：[MVCC讲解](https://zhuanlan.zhihu.com/p/676793594)

### 当前读和快照读

在理解 MVCC 之前我们需要明确**当前读与快照读**两个概念，MVCC 与快照读是高度相关的。

#### 当前读

- 当前读是指事务读取数据时，看到的是数据的**最新版本**，即当前状态。这种读取方式**通常会加锁**，以确保读取的数据不会被其他事务修改。

#### 快照读

- 快照读是事务读取数据时，看到的是事务开始时数据库的一个**一致性快照**。这个快照是基于事务开始时的版本号或时间戳生成的，事务在读取过程中看到的**数据版本是固定的**。
- 每个事务开始前会创建一个一致性视图，该视图反映了事务开始时刻数据库的快照。这个一致性视图会记录当前事务开始时**已经提交的数据版本**。

### MVCC 的定义

- MVCC主要就是为了实现**读-写冲突不加锁**，而这个读指的就是快照读，是乐观锁的实现。
- 所谓数据库多版本并发控制，关键点应该就在于**多版本**。个人理解这个控制机制就是对数据库中的数据**进行版本的备份**，当多个事务进行并发时，数据库中的某些数据可能已经被某个事物修改，但是你并不需要这个修改后的数据，你可以通过某种版本备份机制去选择前面版本数据来继续完成整个事务。
- 那么实现这种机制提炼出来两个关键点就是：
  - 如何保存并且寻找到对应的数据备份（特定的数据版本）？  **Undo Log**
  - 对于某一个事务，你应该去选择哪一个版本的数据？



### Undo Log （Undo 日志）

Undo日志（Undo Log）是 MySQL 中的一种重要的**事务日志**，Undo日志的作用主要有两个方面：

- **事务回滚**：当事务需要回滚时，MySQL 可以通过 Undo 日志中的旧值将数据还原到事务开始之前的状态，保证了事务回滚的一致性。
- **MVCC实现**：MVCC 是[InnoDB存储引擎](https://zhida.zhihu.com/search?content_id=238528742&content_type=Article&match_order=1&q=InnoDB存储引擎&zhida_source=entity)的核心特性之一。通过使用Undo日志，MySQL可以为每个事务提供**独立的事务视图**，使得事务读取数据时能看到一致且符合隔离级别要求的数据版本。

Undo 日志分为两种：

- INSERT：对于插入日志，因为插入的记录只对当前的事务可见，所以事务提交后这条记录会被直接删除，并不会影响到其他的事务。
- UPDATE：对于更新日志与 MVCC 机制相关，所以不能在事务提交时就立即删除。相反，它们会在提交时放入**Undo日志链表**中，并等待purge线程进行最终的删除

#### 隐藏字段

解析 Undo 日志机制需要了解一部分 MySQL 的**隐藏字段**，基于下面这部分字段，InnoDB 实现了 MVCC 机制

| 字段        | 含义                                                         |
| ----------- | ------------------------------------------------------------ |
| DB_ROW_ID   | 隐含的自增ID（隐藏主键），用于唯一标识表中的每一行数据，如果数据表没有主键，InnoDB 会自动以DB_ROW_ID 产生一个聚簇索引。 |
| DB_TRX_ID   | 该字段存储了当前行数据**所属的事务 ID**。每个事务在数据库中都有一个唯一的事务 ID。通过 DB_TRX_ID 字段，可以追踪行数据和事务的所属关系。 |
| DB_ROLL_PTR | 该字段存储了回滚指针（Roll Pointer），它指向用于回滚事务的 [Undo日志](https://zhida.zhihu.com/search?content_id=238528742&content_type=Article&match_order=1&q=Undo日志&zhida_source=entity)记录。 |



#### Undo 日志结构与实现

- MVCC 使用 Undo Log 对过往的事务进行回溯查找从而找到合适的数据版本

- 在参考的文章中给出了一个示例，可以通过示例进行理解：

  1. 事务A：insert into user(id, name) values(1, "小明')
  2. 事务B：update user set name="小王" where id = 1
  3. 事务C：update user set name="小红" where id = 1

  从上倒下并发执行这三个事务，会生成如下图一样的一个 undo 日志链表

  <img src="https://wcx0206.oss-cn-nanjing.aliyuncs.com/image-20250225114205691.png" alt="image-20250225114205691" style="zoom:50%;" />

  我们可以发现在上面的链表中我们通过 `DB_ROLL_PTR` 字段进行连接，通过 `DB_TRX_ID` 记录事务的 Id，然后记录行号以及这个版本的记录的值。 

- 如果需要对事务进行回滚，那么就根据 `DB_ROLL_PTR`  往下进行回溯找到需要的数据版本，然后将对应的数据写回即可。

- MVCC 机制的实现也是这样进行回溯找到第一个**对当前事务可见的**数据版本，而可见性判断就是 MVCC 机制的第二个关键点。



### 可见性原则（基于 Read View 一致性视图）

#### Read View

**一致性视图，全称 Read View ，是用来判断版本链中的哪个版本对当前事务是可见的**

- Read View 说白了就是事务进行**快照读**操作时候生成的**读视图（Read View）**，在该事务执行快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统**当前活跃事务的ID**（每个事务开启时，都会被分配一个ID，这个ID是递增的）。

- 我们需要关注 Read View 维护的一些数据，这些数据会成为下面判断可见性的主要依据。

  | 字段             | 含义                                                         |
  | ---------------- | ------------------------------------------------------------ |
  | m_ids            | Read View **创建时**其他**未提交的活跃事务 ID 列表**。创建 Read View时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务**也是不可见的**。m_ids **不包括当前事务自己和已提交的事务**（正在内存中）。 |
  | m_creator_trx_id | 创建该 Read View 的事务 ID 即自己事务的 ID。                 |
  | m_low_limit_id   | 目前出现过的**最大的事务 ID+1**，即下一个将被分配的事务 ID。**大于等于这个 ID 的数据版本均不可见。** |
  | m_up_limit_id    | **活跃事务列表 m_ids 中最小的事务 ID**，如果 m_ids 为空，则 m_low_limit_id 为m_up_limit_id 。小于这个 ID 的数据版本均可见。 |

这里有一点要注意一下：**Read View只针对 RC 和 RR级别**，想写可参考：[数据库隔离级别](./数据库隔离级别)

#### 判断依据

1. 如果被访问版本的 `DB_TRX_ID` 属性值与 Read View 中的 `m_creator_trx_id` 值相同，表示当前事务正在访问自己所修改的记录，因此该版本可以被当前事务访问。
2. 如果被访问版本的 `DB_TRX_ID`属性值小于 Read View 中的 `m_up_limit_id` 值，说明生成该版本的事务在当前事务生成 Read View 之前已经提交，因此该版本可以被当前事务访问。
3. 如果被访问版本的 `DB_TRX_ID`属性值大于或等于 Read View 中的 `m_low_limit_id` 值，说明生成该版本的事务在当前事务生成 Read View 之后才提交，因此该版本不能被当前事务访问。
4. 如果被访问版本的 `DB_TRX_ID` 属性值位于 Read View 的 `m_up_limit_id` 和 `m_low_limit_id` 之间（包括边界），则需要进一步检查 `DB_TRX_ID`是否在 `m_ids` 列表中。如果在列表中，说明在创建ReadView时生成该版本的事务仍处于活跃状态，因此该版本不能被访问；如果不在列表中，说明在创建 Read View 时生成该版本的事务已经提交，因此该版本可以被访问。

#### 判断过程

- Read View 遵循一个可见性原则，将要被修改的数据的 `DB_TRX_ID` 取出来，与系统当前其他活跃事务的ID去对比。
- 如果 `DB_TRX_ID` 跟 Read View 的属性做了某些比较，不符合可见性，那就通过 `DB_ROLL_PTR` 回滚指针去取出 Undo Log 中的 `DB_TRX_ID` 再比较。
- 即**遍历链表的 DB_TRX_ID** （从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的 DB_TRX_ID，那么这个 DB_TRX_ID 所在的记录就是当前事务能看见的**最新老版本**。

<img src="/Users/wcx/Library/Application Support/typora-user-images/image-20250225164215966.png" alt="image-20250225164215966" style="zoom:50%;" />

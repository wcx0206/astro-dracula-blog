---
title: tcp连接过程
tags:
 - tag1
 - tag2
 - tag3
date: 2025-02-26 10:19:46
---

Tcp 连接过程，主要是三次握手与四次挥手的过程

<!--more-->

参考：[JavaGuide](https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)

![TCP 三次握手图解](https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png)

### 握手与挥手过程中传递的信息解释

#### **SYN（Synchronize Sequence Numbers）**

- **含义**：同步序列编号。
- **作用**：`SYN`是一个标志位，用于在TCP三次握手过程中**初始化一个连接**。当一个TCP报文段的 `SYN` 标志位被设置为1时，表示这是一个**连接请求或连接响应**。
  - **第一次握手**：客户端发送一个带有`SYN`标志的数据包给服务器，表示请求建立连接。
  - **第二次握手**：服务器响应客户端的连接请求，发送一个带有`SYN+ACK`标志的数据包给客户端，表示接受连接请求。

#### **SEQ（Sequence Number）**

- **含义**：序列号。
- **作用**：`SEQ` 是一个32位的无符号整数，用于**标识TCP报文段中的数据顺序**。每个TCP报文段都有一个序列号，用于确保数据的可靠传输和顺序重组。
  - 在**第一次握手**中，客户端发送一个带有`SYN`标志的数据包，并附带一个初始序列号`SEQ=x`。这个序列号是客户端随机生成的，用于**标识后续数据的起始位置**。
  - 在**第二次握手**中，服务器响应客户端的连接请求，发送一个带有 `SYN+ACK` 标志的数据包，并附带自己的初始序列号 `SEQ=y`。同时，服务器会**确认客户端的序列号**，通过 `ACK=x+1` 表示客户端的序列号已被接收并确认。
  - 在**第三次握手**中，客户端发送一个带有 `ACK` 标志的数据包，确认服务器的序列号 `ACK=y+1` ，完成连接的建立。

#### **ACK（Acknowledgment Number）**

- **含义**：确认号。
- **作用**：`ACK` 是一个32位的无符号整数，用于确认对方发送的报文段已被正确接收。`ACK` 字段的值表示**接收方期望收到的下一个字节的序列号**。
  - 在**第二次握手**中，服务器发送一个带有 `SYN+ACK` 标志的数据包，**其中 `ACK=x+1` 表示服务器确认了客户端的初始序列号 `x` ，并期望客户端的下一个字节序列号为 `x+1`**。
  - 在**第三次握手**中，客户端发送一个带有`ACK`标志的数据包，其中`ACK=y+1`表示客户端确认了服务器的初始序列号`y`，并期望服务器的下一个字节序列号为`y+1`。



### 三次握手

1. 第一次握手 Client → Server
   - **传递数据**： **SYN(SEQ=x)**  表示请求与服务端建立连接，并且表示后续数据的起始位置为（X）
   - **产生的作用**：由于服务端接收到了上述传递的数据，所以 Server 可以确认自身接受正常，Client 发送正常
2. 第二次握手 Server → Client
   - **传递数据**：**SYN + ACK (SEQ = y, ACK = x + 1)**  发送 SYN(SEQ) 与上面一样是希望**与客户端建立连接**，并标识后续数据的起始位置为 y，同时传回 ACK 表示自身**正确接收**到了之前客户端传递的数据（x + 1）。
   - **产生的作用**：
     - 由于 Client 接受到了 Server 传递来的 ACK 确认号，所以 Client 可以确认自身发送、接收正常，Server 发送、接收正常
     - Server 可以确认自身接收正常，Client 发送正常
3. 第三次握手 Client → Server
   - **传递数据**：**ACK(ACK = y + 1)** 客户端传回 ACK 表示自己正确接收到了服务端的信息
   - **产生的作用**：
     - Client 可以确认自身发送、接收正常，Server 发送、接收正常
     - 由于 Server 获得了 Client 的确认信息，所以 Server 可以确认自身发送、接收正常，Client 发送、接收正常

![TCP 四次挥手图解](https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-waves-four-times.png)

### 四次挥手

1. 第一次挥手：Client → Serve

   - **传递数据**：**FIN (SEQ=x)**
     客户端发送一个带有 `FIN `标志的数据包给服务器，序列号为 `SEQ=x` 。这表示客户端已经完成数据发送，希望关闭连接。

   - **产生的作用**：
     - 客户端通知服务器自己已经完成数据发送，不再发送新的数据。
     - 客户端进入`FIN_WAIT_1`状态，等待服务器的确认。

2. 第二次挥手：Server → Client

   - **传递数据**：**ACK (ACK=x+1)**
     服务器收到客户端的 `FIN` 请求后，发送一个带有 `ACK` 标志的数据包给客户端，确认号为`ACK=x+1`。这表示服务器已经收到客户端的关闭请求，并确认客户端的序列号 `x` 。

   - **产生的作用**：
     - 客户端收到服务器的确认后，进入 `FIN_WAIT_2` 状态，等待服务器的关闭请求。
     - 服务器进入 `CLOSE_WAIT` 状态，等待自身数据发送完成。

3. 第三次挥手：Server → Client

   - **传递数据**：**FIN (SEQ=y)**
     服务器在完成自身数据发送后，发送一个带有 `FIN` 标志的数据包给客户端，序列号为 `SEQ=y` 。这表示服务器也已经完成数据发送，希望关闭连接。

   - **产生的作用**：
     - 客户端收到服务器的 `FIN` 请求后，进入 `LAST_ACK` 状态，等待确认服务器的关闭请求。
     - 服务器进入 `FIN_WAIT_2` 状态，等待客户端的确认。

4. 第四次挥手：Client → Server

   - **传递数据**：**ACK (ACK=y+1)**
     客户端发送一个带有 `ACK` 标志的数据包给服务器，确认号为 `ACK=y+1` 。这表示客户端已经收到服务器的关闭请求，并确认服务器的序列号 `y` 。

   - **产生的作用**：
     - 客户端进入 `TIME_WAIT` 状态，等待2倍的报文段最大生存时间（2MSL），以确保服务器收到确认信息。
     - 服务器收到客户端的确认后，进入 `CLOSED` 状态，完成连接关闭。
